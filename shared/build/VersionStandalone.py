"""Versioning - classes for managing version values in source files"""

# TODO: VERSION_FILE_TEMPLATE
# The version file may vary and is not automatically generated

import sys
import re


VERSION_KEYS = ['VER_MAJOR', 'VER_MINOR', 'VER_PATCH']

BUILD_KEY = 'VER_BUILD'

# The build number file template
BUILD_FILE_TEMPLATE = """/* 
* DO NOT EDIT! Automatically generated by SCons.
*/

enum {
   // This is the build number used on the next release.
   %s = %d
};
"""

VERSION_VALUE_REGEXP = ".*%s\s*=?\s*(\d+)"


class CVersion(object):
    """CVersion class
    
    Parse and increment the version and build numbers in C, C++ source files.
    """

    def __init__(self, version_file, build_file,
                 version_keys = VERSION_KEYS, build_key = BUILD_KEY):
        'Initialize the Versioner object with the version and build files'
        self.version_file = version_file
        self.build_file = build_file
        self.version_keys = version_keys
        self.build_key = build_key
        self.build_file_template = BUILD_FILE_TEMPLATE
        # read, parse version file(s)
        self.get_current_version()

    def get_build_file(self):
        'Returns the file containing the build version'
        return self.build_file
        
    def set_build_template(self, template):
        self.build_file_template = template
    
    def get_current_version(self):
        '''Read and parse the version files to get the current version.
        Returns: the current version structure
        '''
        fp = open(self.version_file, 'r')
        contents = fp.read()
        fp.close()
        
        version = []
        for key in self.version_keys:
            result = re.search(VERSION_VALUE_REGEXP % key, contents, 
                               re.MULTILINE | re.DOTALL)
            if result:
                version += [ int(result.group(1)) ]
            else:
                raise Exception("Error: '%s' is not a valid version file: can not find %s" % (self.version_file, key))
        version += [ self.get_current_build_number() ]
        self.current_version = version
        return version

    def get_version_str(self, delimiter = '.'):
        'Returns: the version as a string'
        return delimiter.join(str(v) for v in self.current_version)
    
    def get_current_build_number(self):
        '''Read the contents of the given build number file and save it
        for later use.
        Returns: build number, -1 on error
        '''
        # TODO: store the build number
        try:
            fp = open(self.build_file, 'r')
            contents = fp.read()
            fp.close()
            result = re.search(VERSION_VALUE_REGEXP % self.build_key, contents, 
                               re.MULTILINE | re.DOTALL)
            if result:
                self.current_build_number = int(result.group(1))
                return self.current_build_number
            else:
                print "Error: '%s' is not a valid build number file: can not find %s" % (self.build_file, self.build_key)
                return -1
            # Note that this is the *current* build number
            # print "Build: %d" % (build_number) # debug
        except Exception, ex:
            print ex
            return -1

    def increment_build_number(self, build_number=None, dry_run=False):
        '''Increment the build number and regenerate the build number
        file. Returns: the new build number, or -1 on error.
        '''
        try:
            if build_number is None:
                # get the *current* build number
                build_number = self.get_current_build_number()
            # Increment and regenerate the build number file.
            build_number += 1
            if not dry_run:
                print "Incrementing %s for the next build" % self.build_file
                fp = open(self.build_file, 'w')
                fp.write(self.build_file_template % (self.build_key, build_number))
                fp.close()
            else:
                print "DRY RUN: incrementing build number to %d in %s" % (build_number, self.build_file)

            return build_number
        except Exception, ex:
            print "Failed to increment the build number"
            print ex
            return -1

        
    # SCons actions
    
    def increment_version_action(self, target, source, env):
        dry_run = env.has_key('dry_run') and bool(env['dry_run'])
        bn = self.increment_build_number()
        if bn < 0:
            # return a non-zero error code
            return 1
        return 0


import imp

PYTHON_VERSION_FILE_TEMPLATE = """#
# The version in this file is automatically updated by the release script.
#
# PLEASE DO NOT CHANGE THE SYNTAX OF THE VERSION VALUE
# 
VERSION = ({major}, {minor}, {release}, {build})

# END OF FILE
"""

PYTHON_BUILD_INDEX = 3

class PyVersion(object):
    """PyVersion class

    Parse and increment the version numbers in python source files.
    """

    def __init__(self, module_name, version_file):
        'Initialize the PyVersion object with a module name and the path to the version file'
        self.module_name = module_name
        self.version_file = version_file
        self.version_file_template = PYTHON_VERSION_FILE_TEMPLATE
        # read, parse version file(s)
        self.get_current_version()

    def get_build_file(self):
        'Returns the file containing the build version'
        return self.version_file

    def set_build_template(self, template):
        self.version_file_template = template

        
    def get_version_str(self, delimiter = '.'):
        'Returns: the current version as a string'
        return delimiter.join(str(v) for v in self.current_version)
    
    def get_current_version(self):
        '''Read and parse the version files to get the current version.
        Returns: the current version structure
        '''
        self.module = imp.load_source(self.module_name, self.version_file)
        self.current_version = [v for v in self.module.VERSION]
        return self.current_version

    def get_current_build_number(self):
        return self.get_current_version()[PYTHON_BUILD_INDEX]


    def increment_build_number(self, dry_run = False):
        '''Increment the build number and regenerate the version file.
        Returns: next build number, or -1 on error.
        '''
        new_version = self.current_version
        new_version[PYTHON_BUILD_INDEX] += 1
        bnum = new_version[PYTHON_BUILD_INDEX]
        try:
            v_out = self.version_file_template.format(major=new_version[0],
                                                      minor=new_version[1],
                                                      release=new_version[2],
                                                      build=bnum)
            if not dry_run:
                vf = open(self.version_file, 'w')
                vf.write(v_out)
                vf.close()
                print 'Incrementing build number in %s to %d' % (self.version_file,
                                                                 bnum)
            else:
                print 'DRY RUN: incrementing build number in %s to %d' % (self.version_file,
                                                                          bnum)
            return bnum
        
        except Exception, ex:
            print "Failed to increment the build number"
            print ex
            return -1

    
    # SCons actions
    
    def increment_version_action(self, target, source, env):
        dry_run = env.has_key('dry_run') and bool(env['dry_run'])
        bn = self.increment_build_number(dry_run)
        if bn < 0:
            # return a non-zero error code
            return 1
        return 0
